# ECMAScript 6

标签（空格分隔）： js

---

## **1. let和const命令**
1. `for`循环中，循环语句部分是一个父作用域，循环体内部是一个单独的子作用域。函数内部与外部同名变量是分离的。
2. 不存在变量提升。变量要在声明后使用。
3. 暂时性死区（temporal dead zone，简称 TDZ）。在代码块内，使用let，const命令声明变量前不可使用该变量。
4. TDZ意味着typeof不再是一个百分百安全的操作。
5. 不允许重复声明。
6. 允许在块级作用域中声明函数，在作用域外不可使用，但浏览器目前可以使用。
7. `*`do表达式，本质上，块级作用域是一个语句，没有返回值，提案：在作用域前加do，可以返回值。
8. const声明的变量不得改变值，意味着，一旦声明，必须初始化。只声明不赋值会报错。
9. const对于复合型变量，指向数据所在的地址，只保证指向的地址不变。
10. 将对象冻结：`Object.freeze({})`,只冻结了对象，若对象的某个属性是对象，可以改变该对象属性的属性。
11. 变量声明：`var`,`function`,`let`,`const`,`import`,`class`。
12. var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。
```javascript
var constantize = obj => {
    Object.freeze(obj);
    Object.keys(obj).forEach((key,value) => {
        if (typeof obj[key] === 'object') {
            constantize(obj[key]);
        }
    });
};
```

## **2. 解构赋值**
### **1. 数组的解构赋值**
1. 解构不成功，值为`undefined`。只要某种数据结构具有`Iterator`接口，都可以采用数组形式的解构赋值。若没有该接口，会报错。
2. 解构赋值允许指定默认值。若默认值不严格等于`undefined`，默认值不生效。
3. 如果默认值是一个表达式，该表达式是惰性求值的。
4. 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。

### **2. 对象的解构赋值**
1. 对象解构，变量的取值由位置决定，而对象属性无序，变量需与属性同名。
2. 如果变量名与属性名不一致，应写为`let {foo: baz} = {foo: x};bar = x`。说明，对象的解构赋值是下面形式的简写：`let {foo:foo} = {foo:x};foo = x`。
3. 使用解构赋值，变量声明与赋值是一体的。对于`let`和`const`，不能重新声明。
4. 若`let`，`var`已声明，解构赋值应写为`({foo} = {})`，因为解析器会将其解析为代码块，而非赋值语句。
5. 默认值同数组的解构赋值。
6. 如果解构模式是嵌套的对象，且子对象所在的父属性不存在，会报错，因为`undefined`。
7. 解构规则：不是对象先转为对象，由于`undefined`,`null`不能转为对象，会报错。转为对象后若没有Iterator接口则报错。
8. 函数参数解构`{x = 0, y = 0} = {}`。
9. 可以使用圆括号的情况：赋值语句的非模式部分。
10. 用途：
```javascript
// 1. 交换变量的值
[x, y] = [y, x];
// 2. 从函数中返回多个值
function fn(){return [1,2]/{a:1,b:2};}
// 3. 函数参数的定义
function fn([x,y]/{x,y}){}; fn([1,2](有序)/{x:1,y:2}(无序))
// 4. 提取json数据
// 5. 函数参数的默认值
// 6. 遍历Map结构
for (let [key,value] of map){}
// 7. 输入模块的指定方法
const {a,b} = require();
import {a,b} from module;
```


